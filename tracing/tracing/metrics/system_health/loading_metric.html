<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/category_util.html">
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/system_health/breakdown_tree_helpers.html">
<link rel="import" href="/tracing/metrics/system_health/utils.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/timed_event.html">
<link rel="import" href="/tracing/value/histogram.html">
<link rel="import" href="/tracing/extras/chrome/estimated_input_latency.html">

<script>
'use strict';

tr.exportTo('tr.metrics.sh', function() {
  var RESPONSIVENESS_THRESHOLD_MS = 50;
  var INTERACTIVE_WINDOW_SIZE_MS = 5 * 1000;
  var timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  var RelatedEventSet = tr.v.d.RelatedEventSet;
  // Used to counter floating point errors
  const epsilon = 0.1;
  const CONSOLE_ENABLED = false;

  // Wrappers around console so we can easily enable/disable console.
  function consoleWarn(msg) {
    if (!CONSOLE_ENABLED) return;
    console.warn(msg);
  }

  function consoleLog(msg) {
    if (!CONSOLE_ENABLED) return;
    console.log(msg);
  }


  // TODO(ksakamoto): This should be a method of tr.model.Event or one of its
  // subclasses.
  function hasCategoryAndName(event, category, title) {
    return event.title === title && event.category &&
        tr.b.getCategoryParts(event.category).includes(category);
  }

  /**
   * @param {Map.<string, Object>} breakdownTree
   * @return {tr.v.d.Breakdown} A breakdown with categories and the total time
   * (ms) spent under each category.
   */
  function createBreakdownDiagnostic(breakdownTree) {
    var breakdownDiagnostic = new tr.v.d.Breakdown();
    breakdownDiagnostic.colorScheme =
        tr.v.d.COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER;

    for (let label in breakdownTree) {
      breakdownDiagnostic.set(label, breakdownTree[label].total);
    }
    return breakdownDiagnostic;
  }

  /**
   * A utility class for finding navigationStart event for given frame and
   * timestamp.
   * @constructor
   */
  function NavigationStartFinder(rendererHelper) {
    this.navigationStartsForFrameId_ = {};
    for (var ev of rendererHelper.mainThread.sliceGroup.childEvents()) {
      if (!hasCategoryAndName(ev, 'blink.user_timing', 'navigationStart')) {
        continue;
      }
      var frameIdRef = ev.args['frame'];
      var list = this.navigationStartsForFrameId_[frameIdRef];
      if (list === undefined) {
        this.navigationStartsForFrameId_[frameIdRef] = list = [];
      }
      list.unshift(ev);
    }
  }

  NavigationStartFinder.prototype = {
    findNavigationStartEventForFrameBeforeTimestamp: function(frameIdRef, ts) {
      var list = this.navigationStartsForFrameId_[frameIdRef];
      if (list === undefined) return undefined;
      var eventBeforeTimestamp;
      for (var ev of list) {
        if (ev.start > ts) continue;
        if (eventBeforeTimestamp === undefined) {
          eventBeforeTimestamp = ev;
        }
      }
      if (eventBeforeTimestamp === undefined) return undefined;
      return eventBeforeTimestamp;
    }
  };

  var FIRST_PAINT_BOUNDARIES = tr.v.HistogramBinBoundaries
    .createLinear(0, 1e3, 20)  // 50ms step to 1s
    .addLinearBins(3e3, 20) // 100ms step to 3s
    .addExponentialBins(20e3, 20);

  function createHistogram(name) {
    var histogram = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, FIRST_PAINT_BOUNDARIES);
    histogram.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: true,
      std: true,
      sum: false,
    });
    return histogram;
  }

  function findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ts) {
    var snapshot;

    var objects = rendererHelper.process.objects;
    var frameLoaderInstances = objects.instancesByTypeName_['FrameLoader'];
    if (frameLoaderInstances === undefined) return undefined;

    var snapshot;
    for (var instance of frameLoaderInstances) {
      if (!instance.isAliveAt(ts)) continue;
      var maybeSnapshot = instance.getSnapshotAt(ts);
      if (frameIdRef !== maybeSnapshot.args['frame']['id_ref']) continue;
      snapshot = maybeSnapshot;
    }

    return snapshot;
  }

  function findAllUserTimingEvents(rendererHelper, title) {
    var targetEvents = [];

    for (var ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev, 'blink.user_timing', title)) continue;
      targetEvents.push(ev);
    }

    return targetEvents;
  }

  function findFirstMeaningfulPaintCandidates(rendererHelper) {
    var candidatesForFrameId = {};
    for (var ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev, 'loading', 'firstMeaningfulPaintCandidate')) {
        continue;
      }
      if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
      var frameIdRef = ev.args['frame'];
      if (frameIdRef === undefined) continue;
      var list = candidatesForFrameId[frameIdRef];
      if (list === undefined) {
        candidatesForFrameId[frameIdRef] = list = [];
      }
      list.push(ev);
    }
    return candidatesForFrameId;
  }

  function getDCLTimestampsByFrame(rendererHelper) {
    const dclTimestampsByFrame = new Map();
    for (const ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev,
          'blink.user_timing', 'domContentLoadedEventEnd')) {
        continue;
      }

      if (rendererHelper.isTelemetryInternalEvent(ev)) continue;

      var frameIdRef = ev.args['frame'];
      if (frameIdRef === undefined) continue;
      if (!dclTimestampsByFrame.has(frameIdRef)) {
        dclTimestampsByFrame.set(frameIdRef, []); 
      }
      const dclEvents = dclTimestampsByFrame.get(frameIdRef);
      dclEvents.push(ev.start);
    }
    return dclTimestampsByFrame;
  }

  var URL_BLACKLIST = [
    'about:blank',
    // Chrome on Android creates main frames with the below URL for plugins.
    'data:text/html,pluginplaceholderdata',
    // Special URL used to start a navigation to an unreachable error page.
    'data:text/html,chromewebdata'
  ];
  function shouldIgnoreURL(url) {
    return URL_BLACKLIST.includes(url);
  }

  function collectTimeToEvent(
      eventName, rendererHelper, navigationStartFinder) {
    var targetEvents =
        findAllUserTimingEvents(rendererHelper, eventName);
    var samples = [];
    for (var ev of targetEvents) {
      if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
      var frameIdRef = ev.args['frame'];
      var snapshot =
        findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ev.start);
      if (snapshot === undefined || !snapshot.args.isLoadingMainFrame) continue;
      var url = snapshot.args.documentLoaderURL;
      if (shouldIgnoreURL(url)) continue;
      var navigationStartEvent = navigationStartFinder.
        findNavigationStartEventForFrameBeforeTimestamp(
          frameIdRef, ev.start);
      // Ignore layout w/o preceding navigationStart, as they are not
      // attributed to any time-to-X metric.
      if (navigationStartEvent === undefined) continue;

      var timeToEvent = ev.start - navigationStartEvent.start;
      samples.push({
        value: timeToEvent,
        diagnostics: {url: new tr.v.d.Generic(url), eventTimestamp: new tr.v.d.Generic(ev.start),
                      frame: new tr.v.d.Generic(frameIdRef)}
      });
    }
    return samples;
  }

  function addFirstMeaningfulPaintSample(samples, rendererHelper,
      frameIdRef, navigationStart, fmpMarkerEvent) {
    var snapshot = findFrameLoaderSnapshotAt(
        rendererHelper, frameIdRef, fmpMarkerEvent.start);
    if (!snapshot || !snapshot.args.isLoadingMainFrame) return;
    var url = snapshot.args.documentLoaderURL;
    if (shouldIgnoreURL(url)) return;

    var timeToFirstMeaningfulPaint =
        fmpMarkerEvent.start - navigationStart.start;
    var breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, navigationStart.start, fmpMarkerEvent.start);
    var breakdownDiagnostic = createBreakdownDiagnostic(breakdownTree);
    samples.push({
      value: timeToFirstMeaningfulPaint,
      diagnostics: {
          'Breakdown of [navStart, FMP]': breakdownDiagnostic,
          'Start': new RelatedEventSet(navigationStart),
          'End': new RelatedEventSet(fmpMarkerEvent),
          'Navigation infos': new tr.v.d.Generic(
              {url: url, pid: rendererHelper.pid,
                start: navigationStart.start, fmp: fmpMarkerEvent.start,
                frame: frameIdRef}),
      }
    });
    return {firstMeaningfulPaint: fmpMarkerEvent.start, url: url};
  }

  function addFirstMeaningfulPaintCpuTimeSample(samples, rendererHelper,
      frameIdRef, navigationStart, fmpMarkerEvent) {
    var rangeOfInterest = tr.b.math.Range.fromExplicitRange(
        navigationStart.cpuStart, fmpMarkerEvent.cpuStart);
    var snapshot = findFrameLoaderSnapshotAt(
        rendererHelper, frameIdRef, fmpMarkerEvent.start);
    if (!snapshot || !snapshot.args.isLoadingMainFrame) return;
    var url = snapshot.args.documentLoaderURL;
    if (shouldIgnoreURL(url)) return;

    var mainThreadCpuTime = getMainThreadCpuTime(rendererHelper,
        rangeOfInterest);

    var breakdownTree = tr.metrics.sh.generateCpuTimeBreakdownTree(
        rendererHelper.mainThread, navigationStart.cpuStart,
        fmpMarkerEvent.cpuStart);
    var breakdownDiagnostic = createBreakdownDiagnostic(breakdownTree);
    samples.push({
      value: mainThreadCpuTime,
      diagnostics: {
        'Breakdown of [navStart, FMP]': breakdownDiagnostic,
        'Start': new RelatedEventSet(navigationStart),
        'End': new RelatedEventSet(fmpMarkerEvent),
        'Navigation infos': new tr.v.d.Generic({
          url,
          pid: rendererHelper.pid,
          start: navigationStart.start,
          fmp: fmpMarkerEvent.start
        }),
      }
    });
  }

  function getMainThreadCpuTime(rendererHelper, rangeOfInterest) {
    var mainThreadCpuTime = 0;
    for (var slice of rendererHelper.mainThread.sliceGroup.topLevelSlices) {
      if (!slice.cpuDuration) continue;
      var sliceRange = tr.b.math.Range.fromExplicitRange(slice.cpuStart,
          slice.cpuStart + slice.cpuDuration);
      var intersection = rangeOfInterest.findIntersection(sliceRange);
      mainThreadCpuTime += intersection.duration;
    }

    return mainThreadCpuTime;
  }

  function addFirstInteractiveSample(samples, rendererHelper,
      navigationStart, firstMeaningfulPaint, url) {
    if (shouldIgnoreURL(url)) return;
    var navigationStartTime = navigationStart.start;
    var firstInteractive = Infinity;
    var firstInteractiveCandidate = firstMeaningfulPaint;
    var lastLongTaskEvent = undefined;
    // Find the first interactive point X after firstMeaningfulPaint so that
    // range [X, X + INTERACTIVE_WINDOW_SIZE_MS] contains no
    // 'TaskQueueManager::ProcessTaskFromWorkQueues' slice which takes more than
    // RESPONSIVENESS_THRESHOLD_MS.
    // For more details on why TaskQueueManager::ProcessTaskFromWorkQueue is
    // chosen as a proxy for all un-interruptable task on renderer thread, see
    // https://github.com/GoogleChrome/lighthouse/issues/489
    // TODO(nedn): replace this with just "var ev of rendererHelper..." once
    // canary binary is updated.
    // (https://github.com/catapult-project/catapult/issues/2586)
    for (var ev of [...rendererHelper.mainThread.sliceGroup.childEvents()]) {
      if (ev.start < firstInteractiveCandidate) continue;
      var interactiveDurationSoFar = ev.start - firstInteractiveCandidate;
      if (interactiveDurationSoFar >= INTERACTIVE_WINDOW_SIZE_MS) {
        firstInteractive = firstInteractiveCandidate;
        break;
      }
      if (ev.title === 'TaskQueueManager::ProcessTaskFromWorkQueue' &&
          ev.duration > RESPONSIVENESS_THRESHOLD_MS) {
        firstInteractiveCandidate = ev.end - 50;
        lastLongTaskEvent = ev;
      }
    }
    var breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, navigationStartTime, firstInteractive);
    var breakdownDiagnostic = createBreakdownDiagnostic(breakdownTree);

    var timeToFirstInteractive = firstInteractive - navigationStartTime;
    samples.push({
      value: timeToFirstInteractive,
      diagnostics: {
        'Start': new RelatedEventSet(navigationStart),
        'Last long task': new RelatedEventSet(lastLongTaskEvent),
        'Navigation infos': new tr.v.d.Generic({
          url,
          pid: rendererHelper.pid,
          start: navigationStartTime,
          interactive: firstInteractive
        }),
        'Breakdown of [navStart, Interactive]': breakdownDiagnostic,
      }
    });
  }

  /**
   * Computes Time to first meaningful paint (TTFMP) & time to interactive (TTI)
   * for a renderer represented by |rendererHelper| and returns them as
   * histogram samples.
   *
   * First meaningful paint is the paint following the layout with the highest
   * "Layout Significance". The Layout Significance is computed inside Blink,
   * by FirstMeaningfulPaintDetector class. It logs
   * "firstMeaningfulPaintCandidate" event every time the Layout Significance
   * marks a record. TTFMP is the time between NavigationStart and the last
   * firstMeaningfulPaintCandidate event.
   *
   * Design doc: https://goo.gl/vpaxv6
   *
   * TTI is computed as the starting time of the timed window with size
   * INTERACTIVE_WINDOW_SIZE_MS that happens after FMP in which there is no
   * uninterruptable task on the main thread with size more than
   * RESPONSIVENESS_THRESHOLD_MS.
   *
   * Design doc: https://goo.gl/ISWndc
   */
  function collectFirstMeaningfulPaintAndTimeToInteractiveForRenderer(
      rendererHelper, navigationStartFinder) {
    var firstMeaningfulPaintSamples = [];
    var firstMeaningfulPaintCpuTimeSamples = [];
    var firstInteractiveSamples = [];

    function addSamples(frameIdRef, navigationStart, fmpMarkerEvent) {
      var data = addFirstMeaningfulPaintSample(
          firstMeaningfulPaintSamples, rendererHelper,
          frameIdRef, navigationStart, fmpMarkerEvent);
      addFirstMeaningfulPaintCpuTimeSample(
          firstMeaningfulPaintCpuTimeSamples, rendererHelper,
          frameIdRef, navigationStart, fmpMarkerEvent);
      if (data !== undefined) {
        addFirstInteractiveSample(
            firstInteractiveSamples, rendererHelper,
            navigationStart, data.firstMeaningfulPaint, data.url);
      }
    }

    var candidatesForFrameId =
        findFirstMeaningfulPaintCandidates(rendererHelper);

    for (var frameIdRef in candidatesForFrameId) {
      var navigationStart = undefined;
      var lastCandidate = undefined;

      // Iterate over the FMP candidates, remembering the last one.
      for (var ev of candidatesForFrameId[frameIdRef]) {
        var navigationStartForThisCandidate = navigationStartFinder.
          findNavigationStartEventForFrameBeforeTimestamp(
            frameIdRef, ev.start);
        // Ignore candidate w/o preceding navigationStart, as they are not
        // attributed to any TTFMP.
        if (navigationStartForThisCandidate === undefined) continue;

        if (navigationStart !== navigationStartForThisCandidate) {
          // New navigation is found. Compute TTFMP for current navigation,
          // and reset the state variables.
          if (navigationStart !== undefined && lastCandidate !== undefined) {
            addSamples(frameIdRef, navigationStart, lastCandidate);
          }
          navigationStart = navigationStartForThisCandidate;
        }
        lastCandidate = ev;
      }

      // Compute TTFMP for the last navigation.
      if (lastCandidate !== undefined) {
        addSamples(frameIdRef, navigationStart, lastCandidate);
      }
    }
    return {
      firstMeaningfulPaintSamples,
      firstMeaningfulPaintCpuTimeSamples,
      firstInteractiveSamples
    };
  }

  function collectLoadingMetricsForRenderer(rendererHelper) {
    var navigationStartFinder = new NavigationStartFinder(rendererHelper);

    var firstContentfulPaintSamples = collectTimeToEvent(
        'firstContentfulPaint', rendererHelper, navigationStartFinder);
    var onLoadSamples = collectTimeToEvent(
        'loadEventStart', rendererHelper, navigationStartFinder);
    var {firstMeaningfulPaintSamples, firstMeaningfulPaintCpuTimeSamples,
        firstInteractiveSamples} =
        collectFirstMeaningfulPaintAndTimeToInteractiveForRenderer(
            rendererHelper, navigationStartFinder);
    return {
      firstContentfulPaintSamples,
      onLoadSamples,
      firstMeaningfulPaintSamples,
      firstMeaningfulPaintCpuTimeSamples,
      firstInteractiveSamples
    };
  }

  function addSamplesToHistogram(samples, histogram) {
    for (var sample of samples) {
      if (sample !== null) {
        if (typeof(sample) === "number") {
          histogram.addSample(sample);
        } else {
          // Assume sample is of the form {value, diagnostics}
          histogram.addSample(sample.value, sample.diagnostics);
        }
      }
    }
  }

  function addSamplesToExperimentalHistograms(samples, histogramMap, histogramName) {
    if (!histogramMap.has(histogramName)) {
      histogramMap.set(histogramName, createHistogram(histogramName));
    }
    const histogram = histogramMap.get(histogramName);
    addSamplesToHistogram(samples, histogram);
  }

  function addRawSamplesToHistogram(rawSamples, histogram) {
    for (var sample of rawSamples) {
      histogram.addSample(sample);
    }
  }

  function hasTitleAndCategory(event, title, category) {
    return event.title === title && event.category &&
      tr.b.getCategoryParts(event.category).indexOf(category) !== -1;
  }

  function getNavStartEvents(rendererHelper) {
    var navStartEvents = [];
    for (var e of rendererHelper.mainThread.sliceGroup.childEvents()) {
      if (hasTitleAndCategory(e, 'navigationStart', 'blink.user_timing')) {
        navStartEvents.push(e);
      }
    }
    return navStartEvents;
  }

  // This actually ends up sorted the original array despite trying to pretend
  // otherwise. Do not use if you want to preserve the order of the orginal array.
  function numSorted(numericArray) {
    return numericArray.sort((a, b) => a - b);
  }

  function getFISimpleForwardSearch(kwargs) {
    const {searchBegin, windowEnd, mainThreadTasks,
           interactiveWindowSizeMs, isLongTaskFn, dcl} = kwargs;
    const longTaskThreshold = kwargs.longTaskThreshold || 50;
    const isLongTask = isLongTaskFn || (task => task.duration > 50);

    const longTasksInWindow = mainThreadTasks.filter(task =>
        isLongTask(task, searchBegin) &&
        searchBegin <= task.end &&
        task.start <= windowEnd);

    let quietWindowStart = searchBegin;
    for (const task of longTasksInWindow) {
      if ((task.start - quietWindowStart) > interactiveWindowSizeMs) {
        return quietWindowStart;
      }
      quietWindowStart = task.end;
    }

    if ((windowEnd - quietWindowStart) > interactiveWindowSizeMs) {
      return quietWindowStart;
    }

    return null;
  }

  function getFISimpleForwardSearchDCLBounded(kwargs) {
    const {dcl} = kwargs;
    const simpleFI = getFISimpleForwardSearch(kwargs);
    if (!dcl) return simpleFI;
    return Math.max(dcl, simpleFI);
  }

  function getFIReverseSearch(kwargs) {
    const {searchBegin, windowEnd, mainThreadTasks, interactiveWindowSizeMs} = kwargs;
    const longTasksInWindow = mainThreadTasks.filter(task =>
        task.duration >= 50 &&
        searchBegin <= task.end &&
        task.start <= windowEnd);

    const possibleFirstInteractive = longTasksInWindow.length > 0 ?
        longTasksInWindow[longTasksInWindow.length - 1].end : searchBegin;

    if ((windowEnd - possibleFirstInteractive) >= interactiveWindowSizeMs) {
      return possibleFirstInteractive;
    }

    return null;
  }

  function getFIForwardNetwork(kwargs) {
    const {searchBegin, windowEnd, mainThreadTasks,
           interactiveWindowSizeMs, activeRequestTolerance,
           requestsInWindow} = kwargs;

    const longTasksInWindow = mainThreadTasks.filter(task =>
        task.duration >= 50 &&
        searchBegin <= task.end &&
        task.start <= windowEnd);

    const requestsInSearchSpace = requestsInWindow.filter(req =>
        searchBegin <= req.end && req.start <= windowEnd);

    // timestamps of interest
    const endpoints = [];

    for (const task of longTasksInWindow) {
      endpoints.push({
        time: task.start,
        type: "taskStart",
        slice: task
      });
      endpoints.push({
        time: task.end,
        type: "taskEnd",
        slice: task
      });
    };

    for (const req of requestsInSearchSpace) {
      endpoints.push({
        time: req.start,
        type: "requestStart",
        slice: req
      });
      endpoints.push({
        time: req.end,
        type: "requestEnd",
        slice: req
      });
    }

    endpoints.sort((a, b) => a.time - b.time);

    let quietWindowStart = searchBegin;
    let activeNetworkRequests = 0;

    for (const timestamp of endpoints) {
      switch(timestamp.type) {
        case "taskStart":
          if (timestamp.time - quietWindowStart >= interactiveWindowSizeMs &&
              activeNetworkRequests <= activeRequestTolerance) {
            return quietWindowStart;
          }
          quietWindowStart = Math.max(quietWindowStart, timestamp.slice.end);
          break;
        case "taskEnd":
          // Nothing to do.
          break;
        case "requestStart":
          activeNetworkRequests++;
          break;
        case "requestEnd":
          // First check if we just exited a period of network business.
          if (activeNetworkRequests > activeRequestTolerance) {
            quietWindowStart = Math.max(quietWindowStart, timestamp.time);
          }
          activeNetworkRequests--;
          break;
      }
    }

    if (windowEnd - quietWindowStart >= interactiveWindowSizeMs &&
        activeNetworkRequests <= activeRequestTolerance) {
      return quietWindowStart;
    }

    return null;
  }

  function getFIReverseFromNetworkFI(kwargs) {
    const {searchBegin, windowEnd, mainThreadTasks,
           interactiveWindowSizeMs, activeRequestTolerance,
           requestsInWindow} = kwargs;

    const forwardNetworkFI = getFIForwardNetwork(kwargs);
    if (forwardNetworkFI == null) return null;

    const kwargsCopy = Object.assign({}, kwargs);
    kwargsCopy[windowEnd] = forwardNetworkFI + interactiveWindowSizeMs + epsilon;
    const refinedFI = getFIReverseSearch(kwargsCopy);

    // Sanity check: In the worst case, refinedFirstInteractive should be the
    // same as original firstInteractive.
    if (refinedFI === null) throw Error("This should never happen");

    return refinedFI;
  }

  // This is the one where we search backwards from network TTI, but instead of
  // strictly looking for long tasks, we look for windows with high EQT.
  function getFIRevFromNetFIHighEqtWindow(kwargs) {
    const {searchBegin, windowEnd, mainThreadTasks,
           interactiveWindowSizeMs, activeRequestTolerance,
           requestsInWindow, eqtWindowSize, eqtThreshold} = kwargs;

    // Get the network forward search firstInteractive.
    // This is the right boundary of our quest for firstInteractive
    const forwardNetworkFI = getFIForwardNetwork(kwargs);
    if (forwardNetworkFI == null) return null;

    // We're now only interested in the [searchBegin, forwardNetworkFI] range.
    const startTime = searchBegin;
    const endTime = forwardNetworkFI;

    // In case the site has no window of high enough EQT, we start off assuming
    // the site was always interactive, i.e. firstInteractive happens at the
    // beginning of our search window.
    let firstInteractive = searchBegin;

    // All tasks in our current range of interest.
    var tasks = mainThreadTasks.filter(
        t => t.end >= startTime &&
        t.start <= endTime);

    var endpoints = [];
    endpoints.push(startTime);
    endpoints.push(endTime - eqtWindowSize);
    for (var task of tasks) {
      endpoints.push(task.start - eqtWindowSize);
      endpoints.push(task.start);
      endpoints.push(task.end - eqtWindowSize);
      endpoints.push(task.end);
    }
    endpoints = endpoints.filter(
      x => (startTime <= x && x + eqtWindowSize <= endTime));
    // Sort in Descending order
    endpoints.sort((a, b) => b - a);

    var slidingWindow = new tr.e.chrome.SlidingWindow(
      endpoints[0], eqtWindowSize, tasks);

    for (var endpoint of endpoints) {
      slidingWindow.slideBackwards(endpoint);
      if (slidingWindow.getEQT > eqtThreshold) {
        firstInteractive = slidingWindow.range.max;
        break;
      }
    }

    return firstInteractive;
  }

  function getFIForwardSlideInHighEQTWindow(kwargs) {
    const {searchBegin, windowEnd, mainThreadTasks,
           interactiveWindowSizeMs, activeRequestTolerance,
           requestsInWindow, eqtWindowSize, eqtThreshold} = kwargs;

    const backwardHighEQTFI = getFIRevFromNetFIHighEqtWindow(kwargs);
    if (backwardHighEQTFI === null) return null;
    const firstInteractiveFirst = getFISimpleForwardSearch({
      searchBegin: Math.max(backwardHighEQTFI - eqtWindowSize, searchBegin),
      windowEnd: windowEnd,
      mainThreadTasks: mainThreadTasks,
      interactiveWindowSizeMs: 100
    })
    if (firstInteractiveFirst === null) return null;
    const firstInteractiveSecond = getFISimpleForwardSearch({
      searchBegin: firstInteractiveFirst,
      windowEnd: windowEnd,
      mainThreadTasks: mainThreadTasks,
      interactiveWindowSizeMs: 10,
      longTaskThreshold: 5
    })

    return firstInteractiveSecond;
  }

  function isLonely(longTasks, index, windowSize) {
    if (index >= longTasks.length || index < 0) {
      throw Error("index not in longTasks array");
    }

    const currTask = longTasks[index];
    const nextTask = index + 1 === longTasks.length
          ? null : longTasks[index + 1];
    const prevTask = index === 0
          ? null : longTasks[index - 1];

    const lonelyForward =
          nextTask === null
          || nextTask.start - currTask.end > windowSize;
    const lonelyBackward =
          prevTask === null
          || currTask.start - prevTask.end >= windowSize;

    return lonelyForward && lonelyBackward;
  }

  function getFINetRevLonelyTask(kwargs) {
    const {searchBegin, windowEnd, mainThreadTasks,
           interactiveWindowSizeMs, activeRequestTolerance,
           requestsInWindow, lonelyWindowPaddingMs,
           longTaskAbsoluteThreshold} = kwargs;

    const forwardNetworkFI = getFIForwardNetwork(kwargs);
    if (forwardNetworkFI == null) return null;

    const longTasksUntilNetFI = mainThreadTasks.filter(t =>
        t.duration >= 50 &&
        t.end >= searchBegin &&
        t.start <= forwardNetworkFI
    );

    if (longTasksUntilNetFI.length === 0) return searchBegin;

    let i = longTasksUntilNetFI.length - 1;
    while(i >= 0) {
      // Stop if current task is too long
      if (longTasksUntilNetFI[i].duration > longTaskAbsoluteThreshold) break;
      // Stop if current task has another long task nearby
      if (!isLonely(longTasksUntilNetFI, i, lonelyWindowPaddingMs)) break;
      i--;
    }

    return i < 0 ? searchBegin : longTasksUntilNetFI[i].end;
  }

  function getFINetRevLonelyWindow(kwargs) {
    const {searchBegin, windowEnd, mainThreadTasks,
           interactiveWindowSizeMs, activeRequestTolerance,
           requestsInWindow, lonelyWindowSizeMs,
           lonelyWindowPaddingMs, paddingFromSearchBegin} = kwargs;

    const forwardNetworkFI = getFIForwardNetwork(kwargs);
    if (forwardNetworkFI == null) return null;

    const longTasksUntilNetFI = mainThreadTasks.filter(t =>
        t.duration >= 50 &&
        t.end >= searchBegin &&
        t.start <= forwardNetworkFI
    );

    if (longTasksUntilNetFI.length === 0) return searchBegin;

    let i = longTasksUntilNetFI.length - 1;
    let firstInteractive = undefined;
    while(i >= 0) {
      // If task is longer than our lonely window, clearly there is no window
      // that will envelop this long task.
      if (longTasksUntilNetFI[i].duration >= lonelyWindowSizeMs) {
        const task = longTasksUntilNetFI[i];
        const taskStart = task.start;
        const taskEnd = task.end;
        consoleLog(`Task at [${taskStart}, ${taskEnd}] too big to envelop`);
        firstInteractive = longTasksUntilNetFI[i].end;
        break;
      }

      // Right boundary of lonely window.
      const lonelyWindowEnd = longTasksUntilNetFI[i].end;

      // Iterate backward to find the first long task before the lonely window.
      // i--;  // Loop body guarantees one decrement.
      let firstTaskIndexInWindow = i;
      let lastTaskIndexBeforeWindow = firstTaskIndexInWindow - 1;

      const envelopCanGrow = lastTaskIndexBeforeWindow => {
        const taskBeforeWindow = longTasksUntilNetFI[lastTaskIndexBeforeWindow];
        return (lonelyWindowEnd - taskBeforeWindow.start) < lonelyWindowSizeMs;
      }

      while (lastTaskIndexBeforeWindow >= 0
           && envelopCanGrow(lastTaskIndexBeforeWindow)) {
        firstTaskIndexInWindow -= 1;
        lastTaskIndexBeforeWindow = firstTaskIndexInWindow - 1;
      }

      // Make lonely window should be as tight as possible, so it starts at the
      // beginning of the first long task in the window.
      const lonelyWindowStart = longTasksUntilNetFI[firstTaskIndexInWindow].start;

      // Last point before the start of lonely window when the main thread had a
      // long task. If there is no such long task, use searchBegin.
      const previousBusyTimestamp = lastTaskIndexBeforeWindow >= 0 ?
            longTasksUntilNetFI[lastTaskIndexBeforeWindow].end : searchBegin;

      if (lonelyWindowStart - previousBusyTimestamp <= lonelyWindowPaddingMs) {
        consoleLog(`Window not forgiven: [${lonelyWindowStart},` +
            ` ${lonelyWindowEnd}] because previous busy timestamp ` +
            `${previousBusyTimestamp} is too close.`);
        firstInteractive = lonelyWindowEnd;
        break;
      }

      if (lonelyWindowStart - searchBegin <= paddingFromSearchBegin) {
        consoleLog(`Window not forgiven: [${lonelyWindowStart},` +
                ` ${lonelyWindowEnd}] because searchBegin ` +
                   `${searchBegin} is too close.`);
        firstInteractive = lonelyWindowEnd;
        break;
        
      }
      consoleLog(`Window forgiven: [${lonelyWindowStart}, ${lonelyWindowEnd}]`);
      i = lastTaskIndexBeforeWindow;
    }

    return i < 0 ? searchBegin : firstInteractive;
  }
  

  function getNetworkRequests(rendererHelper) {
    return rendererHelper.mainThread.asyncSliceGroup.slices.filter(slice =>
        slice.title === 'ResourceLoad');
  }

  function getActiveNetworkRequests(timestamp, networkRequests) {
    // Brute force algortihm for finding number of active network requests at a
    // given timestamp. Eventually we should optimize this, perhaps using an
    // interval tree.
    var activeRequests = [];
    for (var req of networkRequests) {
      // If a req begins at timestamp, count it as an active request.
      // If a req ends at timestamp, do not count it as an active request.
      if (req.start <= timestamp && timestamp < req.end) activeRequests.push(req);
    }
    return activeRequests;
  }

  function getInteractivePeriodBeginnings(
    firstCandidate, taskWindowEnd, longTasks, interactiveWindowSizeMs) {
    var longTasksInWindow = longTasks.filter(task =>
        firstCandidate <= task.end && task.start <= taskWindowEnd);

    var interactivePeriodBeginnings = [];

    var quietWindowStart = firstCandidate;
    for (var task of longTasksInWindow) {
      if ((task.start - quietWindowStart) > interactiveWindowSizeMs) {
        interactivePeriodBeginnings.push(quietWindowStart);
      }
      quietWindowStart = task.end;
    }

    if ((taskWindowEnd - quietWindowStart) > interactiveWindowSizeMs) {
      interactivePeriodBeginnings.push(quietWindowStart);
    }

    return interactivePeriodBeginnings;
  }

  // Duplicated code from network reverse search to use in the eqt based optimistic tti.
  function findNetworkReverseSearchFirstInteractive(
      firstCandidate, taskWindowEnd, longTasks, networkRequests, interactiveWindowSizeMs) {
    var firstInteractive = findFirstIneractiveInRangeForwardSearchNetwork(
      firstCandidate, taskWindowEnd, longTasks, networkRequests, interactiveWindowSizeMs);

    if (firstInteractive !== null) {
      // Now do a reverseSearch.
      var smallEpsilon = 0.1  // Used to counter floating point errors.
      var refinedFirstInteractive = findFirstIneractiveInRangeReverseSearch(
        firstCandidate, firstInteractive + interactiveWindowSizeMs + smallEpsilon, longTasks, interactiveWindowSizeMs);
      if (refinedFirstInteractive === null) {
        // In the worst case, refinedFirstInteractive should be the same as original
        // firstInteractive.
        throw Error("This should never happen");
      }
      return refinedFirstInteractive;
    }

    return null;
  }

  // This assumes no partial tasks in window
  function getEQT(mainThreadTasks, windowStart, windowEnd) {
    var tasksInWindow = mainThreadTasks.filter(t => t.start >= windowStart && t.end <= windowEnd);
    var windowSize = windowEnd - windowStart;
    var eqt = 0;
    for (var t of tasksInWindow) {
      // eqt += probability of landing on task * mean eqt if landed on task
      eqt += (t.duration / windowSize) * (t.duration / 2);
    }
    return eqt;
  }

  // This is the one where we look at the EQT between two potential
  // firstInteractive candidates and if the EQT is low enough we take the
  // earlier one. Currently unused but code not deleted because the code can
  // potentially be useful later.
  function calculateFirstInteractiveNetRevEQT(
      navStartTimestamps, firstCandidates, networkRequests, longTasks, traceEnd, interactiveWindowSizeMs,
      mainThreadTasks) {

    if (navStartTimestamps.length === 0 || firstCandidates.length === 0) return null;

    for (var i = 0; i < navStartTimestamps.length; i++) {
      // Get our window of interest. A window begings at a navigationStart, and
      // ends either at the next navigationStart, and when we reach end of
      // tracing.
      var taskWindowStart = navStartTimestamps[i];
      var taskWindowEnd = i + 1 < navStartTimestamps.length ?
          navStartTimestamps[i + 1] : traceEnd;

      // Get the firstInteractive candidates that lie within the current window.
      var firstCandidatesInWindow = firstCandidates.filter(candidate =>
          taskWindowStart <= candidate && candidate < taskWindowEnd);

      // We make sure we have only one firstCandidate (e.g. FMP/FCP/DCL) in our
      // window. If we find more than one, this is probably a bug and it's best to bail.
      if (firstCandidatesInWindow.length > 1) return null;
      if (firstCandidatesInWindow.length == 0) continue;
      var firstCandidate = firstCandidatesInWindow[0];

      // Get all forward search firstInteractives with 1s window in given range.
      var interactivePeriodBeginnings = getInteractivePeriodBeginnings(
        firstCandidate, taskWindowEnd, longTasks, 1000);

      // Get the network reverse search firstInteractive.
      // This is the right boundary of our quest for firstInteractive
      var networkReverseFirstInteractive = findNetworkReverseSearchFirstInteractive(
        firstCandidate, taskWindowEnd, longTasks, networkRequests, interactiveWindowSizeMs);

      // We don't really care about interactiveBeginnings beyond networkReverseFirstInteractive
      // Fingers crossed we don't get bit by floating point errors.
      // I don't want to preemptively add an epsilon here, but pls do if bugs show up
      interactivePeriodBeginnings = interactivePeriodBeginnings.filter(
          t => t <= networkReverseFirstInteractive);

      if (interactivePeriodBeginnings.length === 0) return null;
      if (networkReverseFirstInteractive === null) return null;
      // console.log(interactivePeriodBeginnings);
      // console.log(networkReverseFirstInteractive);
      if (interactivePeriodBeginnings[interactivePeriodBeginnings.length - 1] !== networkReverseFirstInteractive) {
        throw new Error("This should not happen");
      }

      // TODO: Now starting from the end, see if EQT between two interactive points is lower than 25ms.
      var j = interactivePeriodBeginnings.length - 1;
      for (var j = interactivePeriodBeginnings.length - 1; j >= 1; j--) {
        // This gets the EQT (as in mean Queuing Time - not a percentile)
        // between the two interactive beginnings.
        // Since we know window start and ends are both ends of long tasks,
        // we do not have to deal with window clippings
        var eqt = getEQT(mainThreadTasks, interactivePeriodBeginnings[j - 1], interactivePeriodBeginnings[j]);
        // console.log(`EQT between ${interactivePeriodBeginnings[j]} and ${interactivePeriodBeginnings[j - 1]}: ${eqt}`);
        if (getEQT(mainThreadTasks, interactivePeriodBeginnings[j - 1],
            interactivePeriodBeginnings[j]) > 25) {
          return interactivePeriodBeginnings[j];
        }
      }
    }

    return interactivePeriodBeginnings[0];
  }

  function findMainLoadingFrames(traceObjects) {
    var frameLoaderInstances = traceObjects.instancesByTypeName_['FrameLoader'];
    var mainFrames = [];
    for (var frameLoaderInstance of frameLoaderInstances) {
      if (frameLoaderInstance.modelItem.snapshots.length > 0 &&
          frameLoaderInstance.modelItem.snapshots[0].isLoadingMainFrame) {
        mainFrames.add
      }
    }
    frameLoaderInstances.map(oi => oi.modelItem.snapshots.map(s => s.args.isLoadingMainFrame))
  }

  // Only returns navigationStart events for the main loading frame
  function getMainFrameNavStartEvents(rendererHelper) {
    return getNavStartEvents(rendererHelper).filter(event => {
      var frameIdRef = event.args['frame'];
      var snapshot = findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, event.start);
      return snapshot && snapshot.args.isLoadingMainFrame;
    });
  }

  function getNavStartTimesByFrame(navStartEvents) {
    var navStartTimesByFrame = new Map();
    for (var e of navStartEvents) {
      var navStartTimestamps = navStartTimesByFrame.get(e.args.frame) || [];
      navStartTimestamps.push(e.start);
      navStartTimesByFrame.set(e.args.frame, navStartTimestamps);
    }
    return navStartTimesByFrame;
  }

  function getFMPTimestampsByFrame(fmpSamples) {
    var fmpTimestampsByFrame = new Map();
    for (var sample of fmpSamples) {
      var frame = sample.diagnostics['Navigation infos'].value.frame;
      var time = sample.diagnostics['Navigation infos'].value.fmp;
      var fmpTimestamps = fmpTimestampsByFrame.get(frame) || [];
      fmpTimestamps.push(time);
      fmpTimestampsByFrame.set(frame, fmpTimestamps);
    }
    return fmpTimestampsByFrame;
  }

  function getFCPTimestampsByFrame(fcpSamples) {
    var fcpTimestampsByFrame = new Map();
    for (var sample of fcpSamples) {
      var frame = sample.diagnostics.frame.value;
      var time = sample.diagnostics.eventTimestamp.value;
      var fcpTimestamps = fcpTimestampsByFrame.get(frame) || [];
      fcpTimestamps.push(time);
      fcpTimestampsByFrame.set(frame, fcpTimestamps);
    }
    return fcpTimestampsByFrame;
  }

  function getUniqueInWindow(ts, windowStart, windowEnd) {
    const filteredTs = ts.filter(t => windowStart <= t && t < windowEnd);

    // We make sure we have only one ts (which is usually FMP/FCP/DCL) in
    // our window. If we find more than one, this is probably a bug and
    // it's best to fail loudly and figure out the underlying issue.
    if (filteredTs.length > 1) throw Error("More than one");
    if (filteredTs.length == 0) return null;

    return filteredTs[0];
  }

  // This returns undefined if there is none is window.
  function getFirstInWindow(ts, windowStart, windowEnd) {
    const filteredTs = ts.filter(t => windowStart <= t && t <= windowEnd);
    return filteredTs[0];
  }

  // This returns undefined if there is none is window.
  function getLastInWindow(ts, windowStart, windowEnd) {
    const filteredTs = ts.filter(t => windowStart <= t && t <= windowEnd);
    return filteredTs[filteredTs.length - 1];
  }

  function anyNull(xs) {
    for (const x of xs) if (x === null) return true;
    return false;
  }

  function addExperimentalFirstInteractiveHistograms(histogramMap, loadingMetrics, rendererHelper) {
    const navStartEvents = getMainFrameNavStartEvents(rendererHelper).filter(event => {
      // Only find navigationStart events for the main loading frame
      var frameIdRef = event.args['frame'];
      var snapshot = findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, event.start);
      return snapshot && snapshot.args.isLoadingMainFrame;
    });
    navStartEvents.sort((a, b) => a.start - b.start);

    const navStartTimesByFrame = getNavStartTimesByFrame(navStartEvents);
    const fmpTimestampsByFrame =
        getFMPTimestampsByFrame(loadingMetrics.firstMeaningfulPaintSamples);
    const fcpTimestampsByFrame =
        getFCPTimestampsByFrame(loadingMetrics.firstContentfulPaintSamples);

    const dclTimestampsByFrame = getDCLTimestampsByFrame(rendererHelper);
    consoleLog('dclTimestampsByFrame', dclTimestampsByFrame);

    const networkRequests = getNetworkRequests(rendererHelper);
    networkRequests.sort((a, b) => a.end - b.end);

    const mainThreadTasks = [];
    for (var e of rendererHelper.mainThread.sliceGroup.childEvents()) {
      if (e.title === 'TaskQueueManager::ProcessTaskFromWorkQueue') {
        mainThreadTasks.push(e);
      }
    }
    mainThreadTasks.sort((a, b) => a.start - b.start);

    var traceEnd = rendererHelper.modelHelper.model.bounds.max;

    for (var [frame, navStartTimestamps] of navStartTimesByFrame) {
      var fmpTimestamps = fmpTimestampsByFrame.get(frame) || [];
      var fcpTimestamps = fcpTimestampsByFrame.get(frame) || [];
      const dclTimestamps = dclTimestampsByFrame.get(frame) || [];

      for (var i = 0; i < navStartTimestamps.length; i++) {
        // Get our window of interest. A window begins at a navigationStart, and
        // ends either at the next navigationStart, and when we reach end of
        // tracing.
        const windowStart = navStartTimestamps[i];
        const windowEnd = i + 1 < navStartTimestamps.length ?
            navStartTimestamps[i + 1] : traceEnd;

        const getUniqueInCurrentWindow = ts => getUniqueInWindow(ts, windowStart, windowEnd);

        const fmp = getUniqueInCurrentWindow(fmpTimestamps);
        const fcp = getUniqueInCurrentWindow(fcpTimestamps);
        const dcl = getLastInWindow(dclTimestamps, windowStart, windowEnd);
        // We need this navigation to at least reach FCP and FMP.
        if (anyNull([fmp, fcp])) continue;

        // All metric calculations should be restricted to objects in the
        // current window.
        const tasksInWindow = mainThreadTasks.filter(t =>
              windowStart <= t.end && t.start <= windowEnd);
        const requestsInWindow = networkRequests.filter(r =>
            windowStart <= r.end && r.start <= windowEnd);

        // Convenient shortcut function.
        // This function is a no-op if sample is null
        const addWithDiagnostics = (name, sample) => {
          const sampleWithDiagnostics = {
            value: sample,
            diagnostics: {
              navigationStart: new tr.v.d.Generic(windowStart),
              tti: new tr.v.d.Generic(sample - windowStart),
              fmp: new tr.v.d.Generic(fmp),
              fcp: new tr.v.d.Generic(fcp),
              frameId: new tr.v.d.Generic(frame)
            }
          };
          addSamplesToExperimentalHistograms(
              [sampleWithDiagnostics], histogramMap, name);
        }

        addWithDiagnostics('firstInteractive-FMP',
            getFISimpleForwardSearch({
              searchBegin: fmp,
              windowEnd: windowEnd,
              mainThreadTasks: mainThreadTasks,
              interactiveWindowSizeMs: 5000
            }));

        addWithDiagnostics('firstInteractive-FMP-Proportional',
                           getFISimpleForwardSearchDCLBounded({
                             searchBegin: fmp,
                             windowEnd: windowEnd,
                             mainThreadTasks: mainThreadTasks,
                             interactiveWindowSizeMs: 5000,
                             isLongTaskFn: (task, searchBegin) => {
                               const timeSinceSearchBegin = task.start - fmp;
                               return task.duration
                                   > Math.max(50, timeSinceSearchBegin / 1000 * 10);
                             },
                             dcl: dcl
                           }));

        for (let windowSize = 1000; windowSize <= 5000; windowSize += 1000) {
          addWithDiagnostics('firstInteractive-FMP-ws-' + windowSize,
              getFISimpleForwardSearch({
                searchBegin: fmp,
                windowEnd: windowEnd,
                mainThreadTasks: mainThreadTasks,
                interactiveWindowSizeMs: windowSize
              }));
        }

        // addWithDiagnostics('firstInteractive-FMP-1s',
        //     getFILayeredForwardSearch({
        //       searchBegin: fmp,
        //       windowEnd: windowEnd,
        //       mainThreadTasks: mainThreadTasks,
        //       interactiveWindowSizeMs: 1000
        //     }));


        // addWithDiagnostics('firstInteractive-FCP',
        //     getFISimpleForwardSearch({
        //       searchBegin: fcp,
        //       windowEnd: windowEnd,
        //       mainThreadTasks: mainThreadTasks,
        //       interactiveWindowSizeMs: 5000
        //     }));

        addWithDiagnostics('firstInteractive-FMP-ReverseSearch',
            getFIReverseSearch({
              searchBegin: fmp,
              windowEnd: windowEnd,
              mainThreadTasks: mainThreadTasks,
              interactiveWindowSizeMs: 5000
            }));

        // addWithDiagnostics('firstInteractive-FCP-ReverseSearch',
        //     getFIReverseSearch({
        //       searchBegin: fcp,
        //       windowEnd: windowEnd,
        //       mainThreadTasks: mainThreadTasks,
        //       interactiveWindowSizeMs: 5000
        //     }));

        addWithDiagnostics('firstInteractive-FMP-Network',
            getFIForwardNetwork({
              searchBegin: fmp,
              windowEnd: windowEnd,
              mainThreadTasks: mainThreadTasks,
              interactiveWindowSizeMs: 5000,
              requestsInWindow: requestsInWindow,
              activeRequestTolerance: 2
            }));

        addWithDiagnostics(
            'firstInteractive-FMP-ReverseSearchFromNetworkFirstInteractive',
            getFIReverseFromNetworkFI({
              searchBegin: fmp,
              windowEnd: windowEnd,
              mainThreadTasks: mainThreadTasks,
              interactiveWindowSizeMs: 5000,
              requestsInWindow: requestsInWindow,
              activeRequestTolerance: 2
            }));

        // for (let windowSize = 350; windowSize <= 500; windowSize += 50) {
        //   for (let eqtThreshold = 8; eqtThreshold <= 12; eqtThreshold += 1) {
        //     const metricName = 'firstInteractiveNetRevHighEQTWindow-' +
        //         `ws-${windowSize}-et-${eqtThreshold}`;
        //     addWithDiagnostics(metricName,
        //         getFIRevFromNetFIHighEqtWindow({
        //           searchBegin: fmp,
        //           windowEnd: windowEnd,
        //           mainThreadTasks: mainThreadTasks,
        //           interactiveWindowSizeMs: 5000,
        //           requestsInWindow: requestsInWindow,
        //           activeRequestTolerance: 2,
        //           eqtWindowSize: windowSize,
        //           eqtThreshold: eqtThreshold
        //         }));
        //   }
        // }

        addWithDiagnostics(
          'firstInteractiveForwardSlideInHighEQTWindow',
          getFIForwardSlideInHighEQTWindow({
            searchBegin: fmp,
            windowEnd: windowEnd,
            mainThreadTasks: mainThreadTasks,
            interactiveWindowSizeMs: 5000,
            requestsInWindow: requestsInWindow,
            activeRequestTolerance: 2,
            // These valued looked good enough in brute force search
            eqtWindowSize: 350,
            eqtThreshold: 12
          })
        );

        addWithDiagnostics(
          'firstInteractiveNetRevLonelyTask',
          getFINetRevLonelyTask({
            searchBegin: fmp,
            windowEnd: windowEnd,
            mainThreadTasks: mainThreadTasks,
            interactiveWindowSizeMs: 5000,
            requestsInWindow: requestsInWindow,
            activeRequestTolerance: 2,
            lonelyWindowPaddingMs: 2000,
            longTaskAbsoluteThreshold: 250
          })
        );

        addWithDiagnostics(
          'firstInteractiveNetRevLonelyWindow',
          getFINetRevLonelyWindow({
            searchBegin: fmp,
            windowEnd: windowEnd,
            mainThreadTasks: mainThreadTasks,
            interactiveWindowSizeMs: 5000,
            requestsInWindow: requestsInWindow,
            activeRequestTolerance: 2,
            lonelyWindowPaddingMs: 1000,
            lonelyWindowSizeMs: 250,
            paddingFromSearchBegin: 5000
          })
        );

        addWithDiagnostics(
          'firstInteractiveProportionalLeniency',
          getFINetRevLonelyWindow({
            searchBegin: fmp,
            windowEnd: windowEnd,
            mainThreadTasks: mainThreadTasks,
            interactiveWindowSizeMs: 5000,
            requestsInWindow: requestsInWindow,
            activeRequestTolerance: 2,
            lonelyWindowPaddingMs: 1000,
            lonelyWindowSizeMs: 250,
            paddingFromSearchBegin: 5000
          })
        );
      }
    }
  }

  function addExperimentalHistogramsToValues(values, histograms) {
    for (var h of histograms.values()) {
      values.addHistogram(h);
    }
  }

  function loadingMetric(values, model) {
    var firstContentfulPaintHistogram = createHistogram(
        'timeToFirstContentfulPaint');
    firstContentfulPaintHistogram.description =
        'time to first contentful paint';
    var onLoadHistogram = createHistogram('timeToOnload');
    onLoadHistogram.description = 'time to onload. ' +
        'This is temporary metric used for PCv1/v2 sanity checking';
    var firstMeaningfulPaintHistogram = createHistogram(
        'timeToFirstMeaningfulPaint');
    firstMeaningfulPaintHistogram.description =
        'time to first meaningful paint';
    var firstMeaningfulPaintCpuTimeHistogram = createHistogram(
        'cpuTimeToFirstMeaningfulPaint');
    firstMeaningfulPaintCpuTimeHistogram.description =
        'CPU time to first meaningful paint';
    var firstInteractiveHistogram = createHistogram('timeToFirstInteractive');
    firstInteractiveHistogram.description = 'time to first interactive';

    var chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);

    const experimentalHistograms = new Map();

    for (var pid in chromeHelper.rendererHelpers) {
      var rendererHelper = chromeHelper.rendererHelpers[pid];
      if (rendererHelper.isChromeTracingUI) continue;

      var rendererLoadingMetrics = collectLoadingMetricsForRenderer(rendererHelper);
      var {firstContentfulPaintSamples, onLoadSamples,
           firstMeaningfulPaintSamples, firstMeaningfulPaintCpuTimeSamples,
           firstInteractiveSamples} = rendererLoadingMetrics;

      addSamplesToHistogram(firstContentfulPaintSamples,
          firstContentfulPaintHistogram);
      addSamplesToHistogram(onLoadSamples, onLoadHistogram);
      addSamplesToHistogram(firstMeaningfulPaintSamples,
          firstMeaningfulPaintHistogram);
      addSamplesToHistogram(firstMeaningfulPaintCpuTimeSamples,
          firstMeaningfulPaintCpuTimeHistogram);
      addSamplesToHistogram(firstInteractiveSamples,
          firstInteractiveHistogram);
      addExperimentalFirstInteractiveHistograms(experimentalHistograms, rendererLoadingMetrics, rendererHelper);
    }


    values.addHistogram(firstContentfulPaintHistogram);
    values.addHistogram(onLoadHistogram);
    values.addHistogram(firstMeaningfulPaintHistogram);
    values.addHistogram(firstInteractiveHistogram);

    addExperimentalHistogramsToValues(values, experimentalHistograms);
  }

  tr.metrics.MetricRegistry.register(loadingMetric);

  return {
    loadingMetric,
    collectLoadingMetricsForRenderer,
    RESPONSIVENESS_THRESHOLD_MS,
    INTERACTIVE_WINDOW_SIZE_MS,
  };
});
</script>
